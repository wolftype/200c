<html>
<script type="text/javascript" src="../js/gfx.js"></script>

<script type="text/javascript">


var box;
var app = new GFX.App();

/// On Initialization of the WebGL Application (this happens once)
app.onInit = function(){

  var vertices = new Float32Array( [
    -1.0, -1.0, -1.0,
    -1.0, 1.0,  -1.0,
    1.0,  1.0,  -1.0,
    1.0,  -1.0, -1.0,
    -1.0, -1.0, 1.0,
    -1.0, 1.0,  1.0,
    1.0,  1.0,  1.0,
    1.0,  -1.0, 1.0,
  ]);

  var colors = new Float32Array([
    1.0,0.0,0.0,
    0.0,1.0,0.0,
    0.0,0.0,1.0,
    1.0,1.0,0.0,
    0.0,1.0,1.0,
    1.0,0.0,1.0,
    0.0,0.0,0.0,
    1.0,1.0,1.0
  ]);  

  var texCoord = new Float32Array([
    0.0, 0.0,
    0.0, 1.0,
    1.0, 1.0,
    1.0, 0.0, 
    1.0, 0.0,
    1.0, 1.0,
    0.0, 1.0,
    0.0, 0.0,   
  ]);  

  var indices = new Uint16Array([
    0,1,3,2,7,6,4,5,0,1
  ]);

  //Create and Bind two new array buffers and a new element array buffer
  box = new GFX.Mesh();

  //Allocate Some Data on the GPU and copy position data over
  box.vertexBuffer.bind();
  box.vertexBuffer.alloc( vertices.byteLength );
  box.vertexBuffer.data(vertices);

  //Allocate Some Data on the GPU and copy color data over
  box.colorBuffer.bind();
  box.colorBuffer.alloc( colors.byteLength );
  box.colorBuffer.data(colors);

  //Allocate Some Data on the GPU and copy color data over
  box.texBuffer.bind();
  box.texBuffer.alloc( texCoord.byteLength );
  box.texBuffer.data(texCoord);

  //Allocate Some Data on the GPU and copy index data over
  box.indexBuffer.bind();
  box.indexBuffer.alloc( indices.byteLength );
  box.indexBuffer.data(indices);
}


// Render the scene
app.onRender = function() {

  var scene = this.scene;

  scene.camera.frame.rotateY( Math.sin( scene.time) * Math.PI / 10  );

  //begin scene render, send matrices over to shader uniform
  scene.begin();

    //Send Time Variable over to GPU
    scene.shader.setUniformFloat("u_time", scene.time )


    //enable attributes in shader
    scene.shader.enableAttribute( "position" );
    scene.shader.enableAttribute( "color" );
    scene.shader.enableAttribute( "uv" );

    //box.frame.rotateX( scene.time );
    //box.frame.scale.x = Math.sin( scene.time );

    //upload model matrix
    box.uploadModel(scene.shader)

    //Bind Vertex Buffer
    box.vertexBuffer.bind();
    //Point Buffer to Attribute in shader
    scene.shader.pointAttribute("position", 3);

    //Bind Color Buffer
    box.colorBuffer.bind();
    //Point Buffer to Attribute in Shader
    scene.shader.pointAttribute("color", 3)

    //Bind TexCoord Buffer
    box.texBuffer.bind();
    //Point Buffer to Attribute in Shader
    scene.shader.pointAttribute("uv", 2)

    //Bind Index Buffer
    box.indexBuffer.bind();
    //Draw the 10 indices
    box.indexBuffer.drawElements(GL.TRIANGLE_STRIP, 10);

  scene.end();
}

</script>

<!-- VERTEX SHADER -->
<script id="gfxvert" type="text/glsl">

  #ifdef GL_ES
  precision lowp float;
  #endif

  attribute vec3 position;      //Position
  attribute vec3 color;         //Color
  attribute vec2 uv;            //Texture;

  uniform mat4 model;           //Model Matrix
  uniform mat4 view;            //View Matrix
  uniform mat4 projection;      //Projection Matrix

  varying vec3 vcolor;          //Color to output to fragment shader
  varying vec2 vuv;             //Texture Coordiante to Output to Fragment Shader

  void main() {
    vuv = uv;
    vcolor = color;
    gl_Position = projection * view * model * vec4(position, 1.0);
  }
</script>


<!-- FRAGMENT SHADER -->
<script id="gfxfrag" type="text/glsl">

  #ifdef GL_ES
  precision lowp float;
  #endif

  uniform float u_time;

  varying vec3 vcolor;
  varying vec2 vuv;

  void main() {
    vec2 st = vuv;
    st = fract(st*2.0 );
    vec3 color = vec3(st.x * sin(u_time), 0., st.y );//vcolor * sin(u_time);
    gl_FragColor = vec4(color,1.0);
  }
</script>

<body onload=app.start()>
<canvas id="gfxcanvas" width=640 height=480> No <code> canvas </code> tag support </canvas>

</body>
</html>